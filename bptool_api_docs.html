<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>bptool API documentation</title>
    <meta name="description" content="This module provides routines for computing the winning probabilities
for various candidates, given ..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#bptool.compute_win_probs">compute_win_probs</a></li>
    <li class="mono"><a href="#bptool.compute_winner">compute_winner</a></li>
    <li class="mono"><a href="#bptool.convert_int_to_32_bit_numpy_array">convert_int_to_32_bit_numpy_array</a></li>
    <li class="mono"><a href="#bptool.create_rs">create_rs</a></li>
    <li class="mono"><a href="#bptool.dirichlet_multinomial">dirichlet_multinomial</a></li>
    <li class="mono"><a href="#bptool.generate_nonsample_tally">generate_nonsample_tally</a></li>
    <li class="mono"><a href="#bptool.main">main</a></li>
    <li class="mono"><a href="#bptool.preprocess_csv">preprocess_csv</a></li>
    <li class="mono"><a href="#bptool.print_results">print_results</a></li>
  </ul>

    </li>


    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">bptool</span> module</h1>
  <p>This module provides routines for computing the winning probabilities
for various candidates, given audit sample data, using a Bayesian
model, in a ballot-polling audit of a plurality election.  The
election may be single-jurisdiction or multi-jurisdiction.  In this
module we call a jurisdiction a "county" for convenience, although it
may be a precinct or a state or something else, as long as you can
sample from its collection of paper ballots.</p>
<p>The Bayesian model uses a prior pseudocount of "+1" for each candidate.</p>
<p>If this module is imported, rather than used stand-alone, then the procedure
    compute_win_probs
can compute the desired probability of each candidate winning a full recount,
given sample tallies for each county.</p>
<p>For command-line usage, there are really two modes:</p>
<p>(1) For single-county usage, give a command like:
        python bptool.py 10000 60 50 30
    where
        10000 is the total number of votes cast in the county
        60 50 30  are the votes seen for each candidate in the auditing so far</p>
<p>(2) For multiple-county usage, give a command like
        python bptool.py --path_to_csv test.csv
    where test.csv is a file like:
        county name, total votes, Alice, Bob
        1, 1000, 30, 15
        2, 2000, 40, 50
    with one header line, then one line per county.  The field names
    "county name" and "total votes" are required; the candidate names are
    the candidate names for the contest being audited.</p>
<p>There are optional parameters as well, to see the documentation of them, do
    python bptool.py --h</p>
<p>More description of Bayesian auditing methods can be found in:</p>
<pre><code>A Bayesian Method for Auditing Elections
by Ronald L. Rivest and Emily Shen
EVN/WOTE'12 Proceedings
http://people.csail.mit.edu/rivest/pubs.html#RS12z

Bayesian Tabulation Audits: Explained and Extended
by Ronald L. Rivest 
2018
http://people.csail.mit.edu/rivest/pubs.html#Riv18a

Bayesian Election Audits in One Page
by Ronald L. Rivest
2018
http://people.csail.mit.edu/rivest/pubs.html#Riv18b
</code></pre>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool', this);">Show source &equiv;</a></p>
  <div id="source-bptool" class="source">
    <pre><code># bptool.py
# Authors: Ronald L. Rivest, Mayuri Sridhar, Zara A Perumal
# April 22, 2018
# python3

"""
This module provides routines for computing the winning probabilities
for various candidates, given audit sample data, using a Bayesian
model, in a ballot-polling audit of a plurality election.  The
election may be single-jurisdiction or multi-jurisdiction.  In this
module we call a jurisdiction a "county" for convenience, although it
may be a precinct or a state or something else, as long as you can
sample from its collection of paper ballots.

The Bayesian model uses a prior pseudocount of "+1" for each candidate.

If this module is imported, rather than used stand-alone, then the procedure
    compute_win_probs
can compute the desired probability of each candidate winning a full recount,
given sample tallies for each county.

For command-line usage, there are really two modes:

(1) For single-county usage, give a command like:
        python bptool.py 10000 60 50 30
    where
        10000 is the total number of votes cast in the county
        60 50 30  are the votes seen for each candidate in the auditing so far

(2) For multiple-county usage, give a command like
        python bptool.py --path_to_csv test.csv
    where test.csv is a file like:
        county name, total votes, Alice, Bob
        1, 1000, 30, 15
        2, 2000, 40, 50
    with one header line, then one line per county.  The field names
    "county name" and "total votes" are required; the candidate names are
    the candidate names for the contest being audited.

There are optional parameters as well, to see the documentation of them, do
    python bptool.py --h

More description of Bayesian auditing methods can be found in:

    A Bayesian Method for Auditing Elections
    by Ronald L. Rivest and Emily Shen
    EVN/WOTE'12 Proceedings
    http://people.csail.mit.edu/rivest/pubs.html#RS12z

    Bayesian Tabulation Audits: Explained and Extended
    by Ronald L. Rivest 
    2018
    http://people.csail.mit.edu/rivest/pubs.html#Riv18a    

    Bayesian Election Audits in One Page
    by Ronald L. Rivest
    2018
    http://people.csail.mit.edu/rivest/pubs.html#Riv18b    
"""

import argparse

from copy import deepcopy
import csv
import sys

import numpy as np

##############################################################################
## Random number generation
##############################################################################

# This function is taken from audit-lab directly.
def convert_int_to_32_bit_numpy_array(v):
    """
    Convert value v, which should be an arbitrarily large python integer
    (or convertible to one) to a numpy array of 32-bit values,
    since this format is needed to initialize a numpy.random.RandomState
    object.  More precisely, the result is a numpy array of type int64,
    but each value is between 0 and 2**32-1, inclusive.

    Example: input 2**64 + 5 yields np.array([5, 0, 1], dtype=int)

    Input Parameters:

    -v is an integer, representing the audit seed that's being
    passed in. We expect v to be non-negative.

    Returns:

    -numpy array created deterministically from v that will
    be used to initialize the Numpy RandomState.
    """

    v = int(v)
    if v < 0:
        raise ValueError(("convert_int_to_32_bit_numpy_array: "
                          "{} is not a nonnegative integer, "
                          "or convertible to one.").format(v))
    v_parts = []
    radix = 2 ** 32
    while v > 0:
        v_parts.append(v % radix)
        v = v // radix
    # note: v_parts will be empty list if v==0, that is OK
    return np.array(v_parts, dtype=int)


def create_rs(seed):
    """
    Create and return a Numpy RandomState object for a given seed.
    The input seed should be a python integer, arbitrarily large.
    The purpose of this routine is to make all the audit actions reproducible.

    Input Parameters:

    -seed is an integer or None. Assuming that it isn't None, we
    convert it into a Numpy Array.

    Returns:

    -a Numpy RandomState object, based on the seed, or the clock
    time if the seed is None.
    """

    if seed is not None:
        seed = convert_int_to_32_bit_numpy_array(seed)
    return np.random.RandomState(seed)


##############################################################################
## Main computational routines
##############################################################################

def dirichlet_multinomial(sample_tally, total_num_votes, rs):
    """
    Return a sample according to the Dirichlet multinomial distribution,
    given a sample tally, the number of votes in the election,
    and a random state. There is an additional pseudocount of
    one vote per candidate in this simulation.

    Input Parameters:

    -sample_tally is a list of integers, where the i'th index
    in sample_tally corresponds to the number of votes that candidate
    i received in the sample.

    -total_num_votes is an integer representing the number of
    ballots that were cast in this election within the county.

    -rs is a Numpy RandomState object that is used for any
    random functions in the simulation of the remaining votes. In particular,
    the gamma functions are made deterministic using this state.

    Returns:

    -multinomial_sample is a list of integers, which sums up
    to the total_num_votes - sample_size. The i'th index represents the
    simulated number of votes for candidate i in the remaining, unsampled
    votes.
    """

    sample_size = sum(sample_tally)
    if sample_size > total_num_votes:
        raise ValueError("total_num_votes {} less than sample_size {}."
                         .format(total_num_votes, sample_size))

    nonsample_size = total_num_votes - sample_size

    pseudocount_for_prior = 1
    sample_with_prior = deepcopy(sample_tally)
    sample_with_prior = [k + pseudocount_for_prior
                         for k in sample_with_prior]

    gamma_sample = [rs.gamma(k) for k in sample_with_prior]
    gamma_sample_sum = float(sum(gamma_sample))
    gamma_sample = [k / gamma_sample_sum for k in gamma_sample]

    multinomial_sample = rs.multinomial(nonsample_size, gamma_sample)

    return multinomial_sample


def generate_nonsample_tally(sample_tally, total_num_votes, seed):
    """
    Given a sample_tally, the total number of votes in an election, and a seed,
    generate the nonsample tally in the election using the Dirichlet multinomial
    distribution.

    Input Parameters:

    -sample_tally is a list of integers, where the i'th index
    in sample_tally corresponds to the number of votes that candidate
    i received in the sample.

    -total_num_votes is an integer representing the number of
    ballots that were cast in this election within the county.

    -seed is an integer or None. Assuming that it isn't None, we
    use it to seed the random state for the audit.

    Returns:

    -nonsample_tally is list of integers, which sums up
    to the total_num_votes - sample_size. The i'th index represents the
    simulated number of votes for candidate i in the remaining, unsampled
    votes.
    """

    rs = create_rs(seed)
    nonsample_tally = dirichlet_multinomial(sample_tally, total_num_votes, rs)
    return nonsample_tally


def compute_winner(sample_tallies, total_num_votes, vote_for_n,
                   seed, pretty_print=False):
    """
    Given a list of sample tallies (one sample tally per county)
    a list giving the total number of votes cast in each county,
    and a random seed (an integer)
    compute the winner in a single simulation.
    For each county, we use the Dirichlet-Multinomial distribution to generate
    a nonsample tally. Then, we sum over all the counties to produce our
    final tally and calculate the predicted winner over all the counties in
    the election.

    Input Parameters:

    -sample_tallies is a list of lists. Each list represents the sample tally
    for a given county. So, sample_tallies[i] represents the tally for county
    i. Then, sample_tallies[i][j] represents the number of votes candidate
    j receives in county i.

    -total_num_votes is a list of integers. Each integer represents the total
    number of votes cast in a given county. So, total_num_votes[i] represents
    the total votes for county i. The sum of all total_num_votes[i] is the
    total number of votes in the entire election.

    -seed is an integer or None. Assuming that it isn't None, we
    use it to seed the random state for the audit.

    -vote_for_n is an integer, parsed from the command-line args. Its default
    value is 1, which means we only calculate a single winner for the election.
    For other values n, we simulate the unnsampled votes and define a win
    for candidate i as any time they are in the top n candidates in the final
    tally.

    -pretty_print is a Boolean, which defaults to False. When it's set to
    True, we print the winning candidate, the number of votes they have
    received and the final vote tally for all the candidates.

    Returns:

    -winners is a list of integers, representing the indices of the candidate
    who won the election. It's size equals the vote_for_n parameter, which
    defaults to 1.
    """
 
    final_tallies = None
    for i, sample_tally in enumerate(sample_tallies):   # loop over counties
        nonsample_tally = generate_nonsample_tally(
            sample_tally, total_num_votes[i], seed)
        final_county_tally = [sum(k)
                              for k in zip(sample_tally, nonsample_tally)]
        if final_tallies is None:
            final_tallies = final_county_tally
        else:
            final_tallies = [sum(k)
                           for k in zip(final_tallies, final_county_tally)]
    final_tallies = [(k, final_tallies[k]) for k in range(len(final_tallies))]
    final_tallies.sort(key = lambda x: x[1])
    winners_with_tallies = final_tallies[-vote_for_n:]
    winners = [winner_tally[0] for winner_tally in winners_with_tallies]
    if pretty_print:
        results_str = ''
        for i in range(len(winners)):
            results_str += (
                "Candidate {} is a winner with {} votes. ".format(
                winners[i], final_tallies[winners[i]][1]))
        results_str += (
            "The final vote tally for all the candidates "
            "was {}".format(
                [final_tally[1] for final_tally in final_tallies]))
        print(results_str)
    return winners


def compute_win_probs(sample_tallies,
                      total_num_votes,
                      seed,
                      num_trials,
                      candidate_names,
                      vote_for_n):
    """

    Runs num_trials simulations of the Bayesian audit to estimate
    the probability that each candidate would win a full recount.

    In particular, we run a single iteration of a Bayesian audit
    (extend each county's sample to simulate all the votes in the
    county and calculate the overall winner across counties)
    num_trials times.

    Input Parameters:

    -sample_tallies is a list of lists. Each list represents the sample tally
    for a given county. So, sample_tallies[i] represents the tally for county
    i. Then, sample_tallies[i][j] represents the number of votes candidate
    j receives in county i.

    -total_num_votes is a list of integers representing the number of
    ballots that were cast in this election. Each integer represents the total
    number of votes cast in a given county. So, total_num_votes[i] represents
    the total votes for county i. The sum of all total_num_votes[i] is the
    total number of votes in the entire election.

    -seed is an integer or None. Assuming that it isn't None, we
    use it to seed the random state for the audit.

    -num_trials is an integer which represents how many simulations
    of the Bayesian audit we run, to estimate the win probabilities
    of the candidates.

    -candidate_names is an ordered list of strings, containing the name of
    every candidate in the contest we are auditing.

    -vote_for_n is an integer, parsed from the command-line args. Its default
    value is 1, which means we only calculate a single winner for the election.
    For other values n, we simulate the unnsampled votes and define a win
    for candidate i as any time they are in the top n candidates in the final
    tally.

    Returns:

    -win_probs is a list of pairs (i, p) where p is the fractional
    representation of the number of trials that candidate i has won
    out of the num_trials simulations.
    """

    num_candidates = len(candidate_names)
    win_count = [0]*(1+num_candidates)
    for i in range(num_trials):
        # We want a different seed per trial.
        # Adding i to seed caused correlations, as numpy apparently
        # adds one per trial, so we multiply i by 314...
        seed_i = seed + i*314159265
        winners = compute_winner(sample_tallies,
                                total_num_votes,
                                vote_for_n,
                                seed_i)
        for winner in winners:
            win_count[winner+1] += 1
    win_probs = [(i, win_count[i]/float(num_trials))
                 for i in range(1, len(win_count))]
    return win_probs


##############################################################################
## Routines for command-line interface and file (csv) input
##############################################################################

def print_results(candidate_names, win_probs, vote_for_n):
    """
    Given list of candidate_names and win_probs pairs, print summary
    of the Bayesian audit simulations.

    Input Parameters:

    -candidate_names is an ordered list of strings, containing the name of
    every candidate in the contest we are auditing.

    -win_probs is a list of pairs (i, p) where p is the fractional
    representation of the number of trials that candidate i has won
    out of the num_trials simulations.

    -vote_for_n is an integer, parsed from the command-line args. Its default
    value is 1, which means we only calculate a single winner for the election.
    For other values n, we simulate the unnsampled votes and define a win
    for candidate i as any time they are in the top n candidates in the final
    tally.

    Returns:

    -None, but prints a summary of how often each candidate has won in
    the simulations.
    """

    print("BPTOOL (Bayesian ballot-polling tool version 0.8)")

    want_sorted_results = True
    if want_sorted_results:
        sorted_win_probs = sorted(
            win_probs, key=lambda tup: tup[1], reverse=True)
    else:
        sorted_win_probs = win_probs

    if vote_for_n == 1:
        print("{:<24s} \t {:<s}"
              .format("Candidate name",
                      "Estimated probability of winning a full recount"))
    else:
        print("{:<24s} \t {:<s} {} {:<s}"
              .format("Candidate name",
                      "Estimated probability of being among the top",
                      vote_for_n,
                      "winners in a full recount"))

    for candidate_index, prob in sorted_win_probs:
        candidate_name = str(candidate_names[candidate_index - 1])
        print(" {:<24s} \t  {:6.2f} %  "
              .format(candidate_name, 100*prob))


def preprocess_csv(path_to_csv):
    """
    Preprocess a CSV file into the correct format for our
    sample tallies. In particular, we ignore the county name column
    and summarize the relevant information about the sample tallies
    in each county, the total number of votes in each county, and
    the candidate names.

    Input Parameters:

    -path_to_csv is a string, representing the full path to the CSV
    file, containing sample tallies.

    Returns:

    -sample_tallies is a list of lists. Each list represents the sample tally
    for a given county. So, sample_tallies[i] represents the tally for county
    i. Then, sample_tallies[i][j] represents the number of votes candidate
    j receives in county i.

    -total_num_votes is a list of integers representing the number of
    ballots that were cast in this election. Each integer represents the total
    number of votes cast in a given county. So, total_num_votes[i] represents
    the total votes for county i.

    -candidate_names is an ordered list of strings, containing the name of
    every candidate in the contest we are auditing.
    """

    with open(path_to_csv) as csvfile:
        sample_tallies = []
        total_num_votes = []
        reader = csv.DictReader(csvfile)
        candidate_names = [col for col in reader.fieldnames
                           if col.strip().lower() not in
                           ["county name", "total votes"]]
        for row in reader:
            sample_tally = []
            for key in row:
                if key.strip().lower() == "county name":
                    continue
                if key.strip().lower() == "total votes":
                    total_num_votes.append(int(row[key]))
                else:
                    count = int(row[key].strip())
                    assert count >= 0
                    sample_tally.append(count)
            sample_tallies.append(sample_tally)

    for i, sample_tally in enumerate(sample_tallies):
        assert 0 <= sum(sample_tally) <= total_num_votes[i]

    return sample_tallies, total_num_votes, candidate_names


def main():
    """
    Parse command-line arguments, compute and print answers.
    """

    parser = argparse.ArgumentParser(description=\
                                     'Bayesian Audit Process For'
                                     'A Single Contest '
                                     'Across One or More Counties')

    parser.add_argument("total_num_votes",
                        nargs="?",
                        help="(Optional: for single-county audits:)"
                             "The total number of votes"
                             "(including the already audited ones) "
                             "that were cast in the election.")

    parser.add_argument("single_county_tally",
                        help="(Optional: for single-county audits:)"
                             " the tally given as space separated numbers,"
                             "e.g.  5 30 25",
                        nargs="*",
                        default=[],
                        type=int)

    parser.add_argument("--path_to_csv",
                        help="If the election spans multiple counties, "
                             "the sample tallies should be given in a csv file."
                             "Give here the csv file pathname as an argument. "
                             "In the header row, one of the column names "
                             "of the csv file must be Total Votes and another "
                             "can be County Name. Other columns are the names "
                             "or identifiers for candidates.")

    parser.add_argument("--audit_seed",
                        help="For reproducibility, we provide the option to "
                             "seed the randomness in the audit. If the same "
                             "seed is provided, the audit will return the "
                             "same results.",
                        type=int,
                        default=1)

    parser.add_argument("--num_trials",
                        help="Bayesian audits work by simulating the data "
                             "which hasn't been sampled to estimate the "
                             "chance that each candidate would win a full "
                             "hand recount. This argument specifies how "
                             "many trials are done to compute these "
                             "estimates.",
                        type=int,
                        default=10000)

    parser.add_argument("--vote_for_n",
                        help="If we want to simulate voting for multiple "
                        "candidates at a time, we can use this parameter "
                        "to specify how many candidates a single voter "
                        "can vote for. The simulations will then count a candidate"
                        "as a winner, each time they appear in the top N "
                        "of the candidates, in the simulated elections.",
                        type=int,
                        default=1)

    args = parser.parse_args()
    if args.path_to_csv is None and args.total_num_votes is None:
        parser.print_help()
        sys.exit()

    if args.path_to_csv:
        # if sample tallies are in CSV file read that
        sample_tallies, total_num_votes, candidate_names = \
            preprocess_csv(args.path_to_csv)
    else:
        # otherwise extract desired data from command line
        total_num_votes = [int(args.total_num_votes)]
        sample_tallies = [args.single_county_tally]
        candidate_names = list(range(1, len(sample_tallies[0]) + 1))

    vote_for_n = args.vote_for_n

    win_probs = compute_win_probs(\
                    sample_tallies,
                    total_num_votes,
                    args.audit_seed,
                    args.num_trials,
                    candidate_names,
                    vote_for_n)
    print_results(candidate_names, win_probs, vote_for_n)


if __name__ == '__main__':

    main()
</code></pre>
  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="bptool.compute_win_probs">
    <p>def <span class="ident">compute_win_probs</span>(</p><p>sample_tallies, total_num_votes, seed, num_trials, candidate_names, vote_for_n)</p>
    </div>
    

    
  
    <div class="desc"><p>Runs num_trials simulations of the Bayesian audit to estimate
the probability that each candidate would win a full recount.</p>
<p>In particular, we run a single iteration of a Bayesian audit
(extend each county's sample to simulate all the votes in the
county and calculate the overall winner across counties)
num_trials times.</p>
<p>Input Parameters:</p>
<p>-sample_tallies is a list of lists. Each list represents the sample tally
for a given county. So, sample_tallies[i] represents the tally for county
i. Then, sample_tallies[i][j] represents the number of votes candidate
j receives in county i.</p>
<p>-total_num_votes is a list of integers representing the number of
ballots that were cast in this election. Each integer represents the total
number of votes cast in a given county. So, total_num_votes[i] represents
the total votes for county i. The sum of all total_num_votes[i] is the
total number of votes in the entire election.</p>
<p>-seed is an integer or None. Assuming that it isn't None, we
use it to seed the random state for the audit.</p>
<p>-num_trials is an integer which represents how many simulations
of the Bayesian audit we run, to estimate the win probabilities
of the candidates.</p>
<p>-candidate_names is an ordered list of strings, containing the name of
every candidate in the contest we are auditing.</p>
<p>-vote_for_n is an integer, parsed from the command-line args. Its default
value is 1, which means we only calculate a single winner for the election.
For other values n, we simulate the unnsampled votes and define a win
for candidate i as any time they are in the top n candidates in the final
tally.</p>
<p>Returns:</p>
<p>-win_probs is a list of pairs (i, p) where p is the fractional
representation of the number of trials that candidate i has won
out of the num_trials simulations.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.compute_win_probs', this);">Show source &equiv;</a></p>
  <div id="source-bptool.compute_win_probs" class="source">
    <pre><code>def compute_win_probs(sample_tallies,
                      total_num_votes,
                      seed,
                      num_trials,
                      candidate_names,
                      vote_for_n):
    """

    Runs num_trials simulations of the Bayesian audit to estimate
    the probability that each candidate would win a full recount.

    In particular, we run a single iteration of a Bayesian audit
    (extend each county's sample to simulate all the votes in the
    county and calculate the overall winner across counties)
    num_trials times.

    Input Parameters:

    -sample_tallies is a list of lists. Each list represents the sample tally
    for a given county. So, sample_tallies[i] represents the tally for county
    i. Then, sample_tallies[i][j] represents the number of votes candidate
    j receives in county i.

    -total_num_votes is a list of integers representing the number of
    ballots that were cast in this election. Each integer represents the total
    number of votes cast in a given county. So, total_num_votes[i] represents
    the total votes for county i. The sum of all total_num_votes[i] is the
    total number of votes in the entire election.

    -seed is an integer or None. Assuming that it isn't None, we
    use it to seed the random state for the audit.

    -num_trials is an integer which represents how many simulations
    of the Bayesian audit we run, to estimate the win probabilities
    of the candidates.

    -candidate_names is an ordered list of strings, containing the name of
    every candidate in the contest we are auditing.

    -vote_for_n is an integer, parsed from the command-line args. Its default
    value is 1, which means we only calculate a single winner for the election.
    For other values n, we simulate the unnsampled votes and define a win
    for candidate i as any time they are in the top n candidates in the final
    tally.

    Returns:

    -win_probs is a list of pairs (i, p) where p is the fractional
    representation of the number of trials that candidate i has won
    out of the num_trials simulations.
    """

    num_candidates = len(candidate_names)
    win_count = [0]*(1+num_candidates)
    for i in range(num_trials):
        # We want a different seed per trial.
        # Adding i to seed caused correlations, as numpy apparently
        # adds one per trial, so we multiply i by 314...
        seed_i = seed + i*314159265
        winners = compute_winner(sample_tallies,
                                total_num_votes,
                                vote_for_n,
                                seed_i)
        for winner in winners:
            win_count[winner+1] += 1
    win_probs = [(i, win_count[i]/float(num_trials))
                 for i in range(1, len(win_count))]
    return win_probs
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.compute_winner">
    <p>def <span class="ident">compute_winner</span>(</p><p>sample_tallies, total_num_votes, vote_for_n, seed, pretty_print=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Given a list of sample tallies (one sample tally per county)
a list giving the total number of votes cast in each county,
and a random seed (an integer)
compute the winner in a single simulation.
For each county, we use the Dirichlet-Multinomial distribution to generate
a nonsample tally. Then, we sum over all the counties to produce our
final tally and calculate the predicted winner over all the counties in
the election.</p>
<p>Input Parameters:</p>
<p>-sample_tallies is a list of lists. Each list represents the sample tally
for a given county. So, sample_tallies[i] represents the tally for county
i. Then, sample_tallies[i][j] represents the number of votes candidate
j receives in county i.</p>
<p>-total_num_votes is a list of integers. Each integer represents the total
number of votes cast in a given county. So, total_num_votes[i] represents
the total votes for county i. The sum of all total_num_votes[i] is the
total number of votes in the entire election.</p>
<p>-seed is an integer or None. Assuming that it isn't None, we
use it to seed the random state for the audit.</p>
<p>-vote_for_n is an integer, parsed from the command-line args. Its default
value is 1, which means we only calculate a single winner for the election.
For other values n, we simulate the unnsampled votes and define a win
for candidate i as any time they are in the top n candidates in the final
tally.</p>
<p>-pretty_print is a Boolean, which defaults to False. When it's set to
True, we print the winning candidate, the number of votes they have
received and the final vote tally for all the candidates.</p>
<p>Returns:</p>
<p>-winners is a list of integers, representing the indices of the candidate
who won the election. It's size equals the vote_for_n parameter, which
defaults to 1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.compute_winner', this);">Show source &equiv;</a></p>
  <div id="source-bptool.compute_winner" class="source">
    <pre><code>def compute_winner(sample_tallies, total_num_votes, vote_for_n,
                   seed, pretty_print=False):
    """
    Given a list of sample tallies (one sample tally per county)
    a list giving the total number of votes cast in each county,
    and a random seed (an integer)
    compute the winner in a single simulation.
    For each county, we use the Dirichlet-Multinomial distribution to generate
    a nonsample tally. Then, we sum over all the counties to produce our
    final tally and calculate the predicted winner over all the counties in
    the election.

    Input Parameters:

    -sample_tallies is a list of lists. Each list represents the sample tally
    for a given county. So, sample_tallies[i] represents the tally for county
    i. Then, sample_tallies[i][j] represents the number of votes candidate
    j receives in county i.

    -total_num_votes is a list of integers. Each integer represents the total
    number of votes cast in a given county. So, total_num_votes[i] represents
    the total votes for county i. The sum of all total_num_votes[i] is the
    total number of votes in the entire election.

    -seed is an integer or None. Assuming that it isn't None, we
    use it to seed the random state for the audit.

    -vote_for_n is an integer, parsed from the command-line args. Its default
    value is 1, which means we only calculate a single winner for the election.
    For other values n, we simulate the unnsampled votes and define a win
    for candidate i as any time they are in the top n candidates in the final
    tally.

    -pretty_print is a Boolean, which defaults to False. When it's set to
    True, we print the winning candidate, the number of votes they have
    received and the final vote tally for all the candidates.

    Returns:

    -winners is a list of integers, representing the indices of the candidate
    who won the election. It's size equals the vote_for_n parameter, which
    defaults to 1.
    """
 
    final_tallies = None
    for i, sample_tally in enumerate(sample_tallies):   # loop over counties
        nonsample_tally = generate_nonsample_tally(
            sample_tally, total_num_votes[i], seed)
        final_county_tally = [sum(k)
                              for k in zip(sample_tally, nonsample_tally)]
        if final_tallies is None:
            final_tallies = final_county_tally
        else:
            final_tallies = [sum(k)
                           for k in zip(final_tallies, final_county_tally)]
    final_tallies = [(k, final_tallies[k]) for k in range(len(final_tallies))]
    final_tallies.sort(key = lambda x: x[1])
    winners_with_tallies = final_tallies[-vote_for_n:]
    winners = [winner_tally[0] for winner_tally in winners_with_tallies]
    if pretty_print:
        results_str = ''
        for i in range(len(winners)):
            results_str += (
                "Candidate {} is a winner with {} votes. ".format(
                winners[i], final_tallies[winners[i]][1]))
        results_str += (
            "The final vote tally for all the candidates "
            "was {}".format(
                [final_tally[1] for final_tally in final_tallies]))
        print(results_str)
    return winners
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.convert_int_to_32_bit_numpy_array">
    <p>def <span class="ident">convert_int_to_32_bit_numpy_array</span>(</p><p>v)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert value v, which should be an arbitrarily large python integer
(or convertible to one) to a numpy array of 32-bit values,
since this format is needed to initialize a numpy.random.RandomState
object.  More precisely, the result is a numpy array of type int64,
but each value is between 0 and 2**32-1, inclusive.</p>
<p>Example: input 2**64 + 5 yields np.array([5, 0, 1], dtype=int)</p>
<p>Input Parameters:</p>
<p>-v is an integer, representing the audit seed that's being
passed in. We expect v to be non-negative.</p>
<p>Returns:</p>
<p>-numpy array created deterministically from v that will
be used to initialize the Numpy RandomState.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.convert_int_to_32_bit_numpy_array', this);">Show source &equiv;</a></p>
  <div id="source-bptool.convert_int_to_32_bit_numpy_array" class="source">
    <pre><code>def convert_int_to_32_bit_numpy_array(v):
    """
    Convert value v, which should be an arbitrarily large python integer
    (or convertible to one) to a numpy array of 32-bit values,
    since this format is needed to initialize a numpy.random.RandomState
    object.  More precisely, the result is a numpy array of type int64,
    but each value is between 0 and 2**32-1, inclusive.

    Example: input 2**64 + 5 yields np.array([5, 0, 1], dtype=int)

    Input Parameters:

    -v is an integer, representing the audit seed that's being
    passed in. We expect v to be non-negative.

    Returns:

    -numpy array created deterministically from v that will
    be used to initialize the Numpy RandomState.
    """

    v = int(v)
    if v < 0:
        raise ValueError(("convert_int_to_32_bit_numpy_array: "
                          "{} is not a nonnegative integer, "
                          "or convertible to one.").format(v))
    v_parts = []
    radix = 2 ** 32
    while v > 0:
        v_parts.append(v % radix)
        v = v // radix
    # note: v_parts will be empty list if v==0, that is OK
    return np.array(v_parts, dtype=int)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.create_rs">
    <p>def <span class="ident">create_rs</span>(</p><p>seed)</p>
    </div>
    

    
  
    <div class="desc"><p>Create and return a Numpy RandomState object for a given seed.
The input seed should be a python integer, arbitrarily large.
The purpose of this routine is to make all the audit actions reproducible.</p>
<p>Input Parameters:</p>
<p>-seed is an integer or None. Assuming that it isn't None, we
convert it into a Numpy Array.</p>
<p>Returns:</p>
<p>-a Numpy RandomState object, based on the seed, or the clock
time if the seed is None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.create_rs', this);">Show source &equiv;</a></p>
  <div id="source-bptool.create_rs" class="source">
    <pre><code>def create_rs(seed):
    """
    Create and return a Numpy RandomState object for a given seed.
    The input seed should be a python integer, arbitrarily large.
    The purpose of this routine is to make all the audit actions reproducible.

    Input Parameters:

    -seed is an integer or None. Assuming that it isn't None, we
    convert it into a Numpy Array.

    Returns:

    -a Numpy RandomState object, based on the seed, or the clock
    time if the seed is None.
    """

    if seed is not None:
        seed = convert_int_to_32_bit_numpy_array(seed)
    return np.random.RandomState(seed)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.dirichlet_multinomial">
    <p>def <span class="ident">dirichlet_multinomial</span>(</p><p>sample_tally, total_num_votes, rs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a sample according to the Dirichlet multinomial distribution,
given a sample tally, the number of votes in the election,
and a random state. There is an additional pseudocount of
one vote per candidate in this simulation.</p>
<p>Input Parameters:</p>
<p>-sample_tally is a list of integers, where the i'th index
in sample_tally corresponds to the number of votes that candidate
i received in the sample.</p>
<p>-total_num_votes is an integer representing the number of
ballots that were cast in this election within the county.</p>
<p>-rs is a Numpy RandomState object that is used for any
random functions in the simulation of the remaining votes. In particular,
the gamma functions are made deterministic using this state.</p>
<p>Returns:</p>
<p>-multinomial_sample is a list of integers, which sums up
to the total_num_votes - sample_size. The i'th index represents the
simulated number of votes for candidate i in the remaining, unsampled
votes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.dirichlet_multinomial', this);">Show source &equiv;</a></p>
  <div id="source-bptool.dirichlet_multinomial" class="source">
    <pre><code>def dirichlet_multinomial(sample_tally, total_num_votes, rs):
    """
    Return a sample according to the Dirichlet multinomial distribution,
    given a sample tally, the number of votes in the election,
    and a random state. There is an additional pseudocount of
    one vote per candidate in this simulation.

    Input Parameters:

    -sample_tally is a list of integers, where the i'th index
    in sample_tally corresponds to the number of votes that candidate
    i received in the sample.

    -total_num_votes is an integer representing the number of
    ballots that were cast in this election within the county.

    -rs is a Numpy RandomState object that is used for any
    random functions in the simulation of the remaining votes. In particular,
    the gamma functions are made deterministic using this state.

    Returns:

    -multinomial_sample is a list of integers, which sums up
    to the total_num_votes - sample_size. The i'th index represents the
    simulated number of votes for candidate i in the remaining, unsampled
    votes.
    """

    sample_size = sum(sample_tally)
    if sample_size > total_num_votes:
        raise ValueError("total_num_votes {} less than sample_size {}."
                         .format(total_num_votes, sample_size))

    nonsample_size = total_num_votes - sample_size

    pseudocount_for_prior = 1
    sample_with_prior = deepcopy(sample_tally)
    sample_with_prior = [k + pseudocount_for_prior
                         for k in sample_with_prior]

    gamma_sample = [rs.gamma(k) for k in sample_with_prior]
    gamma_sample_sum = float(sum(gamma_sample))
    gamma_sample = [k / gamma_sample_sum for k in gamma_sample]

    multinomial_sample = rs.multinomial(nonsample_size, gamma_sample)

    return multinomial_sample
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.generate_nonsample_tally">
    <p>def <span class="ident">generate_nonsample_tally</span>(</p><p>sample_tally, total_num_votes, seed)</p>
    </div>
    

    
  
    <div class="desc"><p>Given a sample_tally, the total number of votes in an election, and a seed,
generate the nonsample tally in the election using the Dirichlet multinomial
distribution.</p>
<p>Input Parameters:</p>
<p>-sample_tally is a list of integers, where the i'th index
in sample_tally corresponds to the number of votes that candidate
i received in the sample.</p>
<p>-total_num_votes is an integer representing the number of
ballots that were cast in this election within the county.</p>
<p>-seed is an integer or None. Assuming that it isn't None, we
use it to seed the random state for the audit.</p>
<p>Returns:</p>
<p>-nonsample_tally is list of integers, which sums up
to the total_num_votes - sample_size. The i'th index represents the
simulated number of votes for candidate i in the remaining, unsampled
votes.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.generate_nonsample_tally', this);">Show source &equiv;</a></p>
  <div id="source-bptool.generate_nonsample_tally" class="source">
    <pre><code>def generate_nonsample_tally(sample_tally, total_num_votes, seed):
    """
    Given a sample_tally, the total number of votes in an election, and a seed,
    generate the nonsample tally in the election using the Dirichlet multinomial
    distribution.

    Input Parameters:

    -sample_tally is a list of integers, where the i'th index
    in sample_tally corresponds to the number of votes that candidate
    i received in the sample.

    -total_num_votes is an integer representing the number of
    ballots that were cast in this election within the county.

    -seed is an integer or None. Assuming that it isn't None, we
    use it to seed the random state for the audit.

    Returns:

    -nonsample_tally is list of integers, which sums up
    to the total_num_votes - sample_size. The i'th index represents the
    simulated number of votes for candidate i in the remaining, unsampled
    votes.
    """

    rs = create_rs(seed)
    nonsample_tally = dirichlet_multinomial(sample_tally, total_num_votes, rs)
    return nonsample_tally
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.main">
    <p>def <span class="ident">main</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Parse command-line arguments, compute and print answers.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.main', this);">Show source &equiv;</a></p>
  <div id="source-bptool.main" class="source">
    <pre><code>def main():
    """
    Parse command-line arguments, compute and print answers.
    """

    parser = argparse.ArgumentParser(description=\
                                     'Bayesian Audit Process For'
                                     'A Single Contest '
                                     'Across One or More Counties')

    parser.add_argument("total_num_votes",
                        nargs="?",
                        help="(Optional: for single-county audits:)"
                             "The total number of votes"
                             "(including the already audited ones) "
                             "that were cast in the election.")

    parser.add_argument("single_county_tally",
                        help="(Optional: for single-county audits:)"
                             " the tally given as space separated numbers,"
                             "e.g.  5 30 25",
                        nargs="*",
                        default=[],
                        type=int)

    parser.add_argument("--path_to_csv",
                        help="If the election spans multiple counties, "
                             "the sample tallies should be given in a csv file."
                             "Give here the csv file pathname as an argument. "
                             "In the header row, one of the column names "
                             "of the csv file must be Total Votes and another "
                             "can be County Name. Other columns are the names "
                             "or identifiers for candidates.")

    parser.add_argument("--audit_seed",
                        help="For reproducibility, we provide the option to "
                             "seed the randomness in the audit. If the same "
                             "seed is provided, the audit will return the "
                             "same results.",
                        type=int,
                        default=1)

    parser.add_argument("--num_trials",
                        help="Bayesian audits work by simulating the data "
                             "which hasn't been sampled to estimate the "
                             "chance that each candidate would win a full "
                             "hand recount. This argument specifies how "
                             "many trials are done to compute these "
                             "estimates.",
                        type=int,
                        default=10000)

    parser.add_argument("--vote_for_n",
                        help="If we want to simulate voting for multiple "
                        "candidates at a time, we can use this parameter "
                        "to specify how many candidates a single voter "
                        "can vote for. The simulations will then count a candidate"
                        "as a winner, each time they appear in the top N "
                        "of the candidates, in the simulated elections.",
                        type=int,
                        default=1)

    args = parser.parse_args()
    if args.path_to_csv is None and args.total_num_votes is None:
        parser.print_help()
        sys.exit()

    if args.path_to_csv:
        # if sample tallies are in CSV file read that
        sample_tallies, total_num_votes, candidate_names = \
            preprocess_csv(args.path_to_csv)
    else:
        # otherwise extract desired data from command line
        total_num_votes = [int(args.total_num_votes)]
        sample_tallies = [args.single_county_tally]
        candidate_names = list(range(1, len(sample_tallies[0]) + 1))

    vote_for_n = args.vote_for_n

    win_probs = compute_win_probs(\
                    sample_tallies,
                    total_num_votes,
                    args.audit_seed,
                    args.num_trials,
                    candidate_names,
                    vote_for_n)
    print_results(candidate_names, win_probs, vote_for_n)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.preprocess_csv">
    <p>def <span class="ident">preprocess_csv</span>(</p><p>path_to_csv)</p>
    </div>
    

    
  
    <div class="desc"><p>Preprocess a CSV file into the correct format for our
sample tallies. In particular, we ignore the county name column
and summarize the relevant information about the sample tallies
in each county, the total number of votes in each county, and
the candidate names.</p>
<p>Input Parameters:</p>
<p>-path_to_csv is a string, representing the full path to the CSV
file, containing sample tallies.</p>
<p>Returns:</p>
<p>-sample_tallies is a list of lists. Each list represents the sample tally
for a given county. So, sample_tallies[i] represents the tally for county
i. Then, sample_tallies[i][j] represents the number of votes candidate
j receives in county i.</p>
<p>-total_num_votes is a list of integers representing the number of
ballots that were cast in this election. Each integer represents the total
number of votes cast in a given county. So, total_num_votes[i] represents
the total votes for county i.</p>
<p>-candidate_names is an ordered list of strings, containing the name of
every candidate in the contest we are auditing.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.preprocess_csv', this);">Show source &equiv;</a></p>
  <div id="source-bptool.preprocess_csv" class="source">
    <pre><code>def preprocess_csv(path_to_csv):
    """
    Preprocess a CSV file into the correct format for our
    sample tallies. In particular, we ignore the county name column
    and summarize the relevant information about the sample tallies
    in each county, the total number of votes in each county, and
    the candidate names.

    Input Parameters:

    -path_to_csv is a string, representing the full path to the CSV
    file, containing sample tallies.

    Returns:

    -sample_tallies is a list of lists. Each list represents the sample tally
    for a given county. So, sample_tallies[i] represents the tally for county
    i. Then, sample_tallies[i][j] represents the number of votes candidate
    j receives in county i.

    -total_num_votes is a list of integers representing the number of
    ballots that were cast in this election. Each integer represents the total
    number of votes cast in a given county. So, total_num_votes[i] represents
    the total votes for county i.

    -candidate_names is an ordered list of strings, containing the name of
    every candidate in the contest we are auditing.
    """

    with open(path_to_csv) as csvfile:
        sample_tallies = []
        total_num_votes = []
        reader = csv.DictReader(csvfile)
        candidate_names = [col for col in reader.fieldnames
                           if col.strip().lower() not in
                           ["county name", "total votes"]]
        for row in reader:
            sample_tally = []
            for key in row:
                if key.strip().lower() == "county name":
                    continue
                if key.strip().lower() == "total votes":
                    total_num_votes.append(int(row[key]))
                else:
                    count = int(row[key].strip())
                    assert count >= 0
                    sample_tally.append(count)
            sample_tallies.append(sample_tally)

    for i, sample_tally in enumerate(sample_tallies):
        assert 0 <= sum(sample_tally) <= total_num_votes[i]

    return sample_tallies, total_num_votes, candidate_names
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="bptool.print_results">
    <p>def <span class="ident">print_results</span>(</p><p>candidate_names, win_probs, vote_for_n)</p>
    </div>
    

    
  
    <div class="desc"><p>Given list of candidate_names and win_probs pairs, print summary
of the Bayesian audit simulations.</p>
<p>Input Parameters:</p>
<p>-candidate_names is an ordered list of strings, containing the name of
every candidate in the contest we are auditing.</p>
<p>-win_probs is a list of pairs (i, p) where p is the fractional
representation of the number of trials that candidate i has won
out of the num_trials simulations.</p>
<p>-vote_for_n is an integer, parsed from the command-line args. Its default
value is 1, which means we only calculate a single winner for the election.
For other values n, we simulate the unnsampled votes and define a win
for candidate i as any time they are in the top n candidates in the final
tally.</p>
<p>Returns:</p>
<p>-None, but prints a summary of how often each candidate has won in
the simulations.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-bptool.print_results', this);">Show source &equiv;</a></p>
  <div id="source-bptool.print_results" class="source">
    <pre><code>def print_results(candidate_names, win_probs, vote_for_n):
    """
    Given list of candidate_names and win_probs pairs, print summary
    of the Bayesian audit simulations.

    Input Parameters:

    -candidate_names is an ordered list of strings, containing the name of
    every candidate in the contest we are auditing.

    -win_probs is a list of pairs (i, p) where p is the fractional
    representation of the number of trials that candidate i has won
    out of the num_trials simulations.

    -vote_for_n is an integer, parsed from the command-line args. Its default
    value is 1, which means we only calculate a single winner for the election.
    For other values n, we simulate the unnsampled votes and define a win
    for candidate i as any time they are in the top n candidates in the final
    tally.

    Returns:

    -None, but prints a summary of how often each candidate has won in
    the simulations.
    """

    print("BPTOOL (Bayesian ballot-polling tool version 0.8)")

    want_sorted_results = True
    if want_sorted_results:
        sorted_win_probs = sorted(
            win_probs, key=lambda tup: tup[1], reverse=True)
    else:
        sorted_win_probs = win_probs

    if vote_for_n == 1:
        print("{:<24s} \t {:<s}"
              .format("Candidate name",
                      "Estimated probability of winning a full recount"))
    else:
        print("{:<24s} \t {:<s} {} {:<s}"
              .format("Candidate name",
                      "Estimated probability of being among the top",
                      vote_for_n,
                      "winners in a full recount"))

    for candidate_index, prob in sorted_win_probs:
        candidate_name = str(candidate_names[candidate_index - 1])
        print(" {:<24s} \t  {:6.2f} %  "
              .format(candidate_name, 100*prob))
</code></pre>
  </div>
</div>

  </div>
  


  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
